# （1）可以使用“+”运算符将元素添加到列表中。
aList = [3,4,5]
aList = aList + [7]
print(aList)
# [3, 4, 5, 7]
# 严格意义上来讲，这并不是真的为列表添加元素，而是创建了一个新列表，并将原列表中的元素和新元素依次复制到新列表的内存空间。由于涉及大量元素的复制，该操作速度较慢，在涉及大量元素添加时不建议使用该方法。

# （2）使用列表对象的append()方法在当前列表尾部追加元素，原地修改列表，是真正意义上的在列表尾部添加元素，速度较快。
aList.append(9)
print(aList)
# [3, 4, 5, 7, 9]

# Python采用的是基于值的自动内存管理方式，当为对象修改值时，并不是真的直接修改变量的值，而是使变量指向新的值，这对于Python所有类型的变量都是一样的。
a = [1,2,3]
print(id(a))                        #返回对象的内存地址
# 20230752
a = [1,2]
print(id(a))
# 20338208

# 列表中包含的是元素值的引用，而不是直接包含元素值。
# 如果是直接修改序列变量的值，则与Python普通变量的情况是一样的
# 如果是通过下标来修改序列中元素的值或通过可变序列对象自身提供的方法来增加和删除元素时，序列对象在内存中的起始地址是不变的，仅仅是被改变值的元素地址发生变化，也就是所谓的“原地操作”。
a = [1, 2, 3]
print(id(a))
# 2389572193096
a.append(4)
a.remove(3)
a[0] = 5
print(a)
# [5, 2, 4]
print(id(a))
# 2389572193096

# （3）使用列表对象的extend()方法可以将另一个迭代对象的所有元素添加至该列表对象尾部。通过extend()方法来增加列表元素也不改变其内存首地址，属于原地操作。
a.extend([7,8,9])
print(a)
# [5, 2, 4, 7, 8, 9]
aList.extend([11,13])
print(aList)
# [3, 4, 5, 7, 9, 11, 13]
aList.extend((15,17))
print(aList)
# [3, 4, 5, 7, 9, 11, 13, 15, 17]

# 运算符+=类似于列表的extend()方法。
x = []
x += '1234'
print(x)
# ['1', '2', '3', '4']
x += range(3)
print(x)
# ['1', '2', '3', '4', 0, 1, 2]
x += map(str, range(3))
print(x)
# ['1', '2', '3', '4', 0, 1, 2, '0', '1', '2']

# （4）使用列表对象的insert()方法将元素添加至列表的指定位置。
aList.insert(3, 6)                #在下标为3的位置插入元素6
print(aList)
# [3, 4, 5, 6, 7, 9, 11, 13, 15, 17]

# 列表的insert()可以在列表的任意位置插入元素，但由于列表的自动内存管理功能，insert()方法会引起插入位置之后所有元素的移动，这会影响处理速度。
# 类似的还有后面介绍的remove()方法以及使用pop()函数弹出列表非尾部元素和使用del命令删除列表非尾部元素的情况。
# （5）使用乘法来扩展列表对象，将列表与整数相乘，生成一个新列表，新列表是原列表中元素的重复。
aList = [3,5,7]
aList * 3
# [3, 5, 7, 3, 5, 7, 3, 5, 7]
# 当使用*运算符将包含列表的列表重复并创建新列表时，并不是复制子列表值，而是复制已有元素的引用。因此，当修改其中一个值时，相应的引用也会被修改。
x = [[None] * 2] * 3
print(x)
# [[None, None], [None, None], [None, None]]
x[0][0] = 5
print(x)
# [[5, None], [5, None], [5, None]]

